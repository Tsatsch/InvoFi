Почему нельзя просто изменить баланс токен-аккаунта так: `account.amount -= 100`?;Потому что токен-аккаунты принадлежат не нашей программе, а официальной Токен-Программе Solana. Мы можем только отправлять ей "запросы" (CPI) на изменение баланса, но не можем делать это напрямую.
Что такое `AccountInfo` и зачем нужен метод `.to_account_info()`?;`AccountInfo` — это "паспорт" любого аккаунта в Solana, содержащий сырые данные (адрес, владелец, байты). Anchor использует его для создания удобных структур (например, `Account<'info, TokenAccount>`). Метод `.to_account_info()` нужен, чтобы "распаковать" удобную структуру Anchor обратно в "паспорт" для передачи в другие программы через CPI.
В чем разница между `Account<'info, T>`, `Program<'info, T>` и `InterfaceAccount<'info, T>`?;`Account`: для аккаунтов, хранящих ДАННЫЕ (AmmConfig, TokenAccount). `Program`: для ИСПОЛНЯЕМЫХ ПРОГРАММ (System Program, Token Program). `InterfaceAccount`: для продвинутых случаев, когда аккаунт должен соответствовать интерфейсу (trait), а не конкретной структуре.
Зачем нужно ограничение `#[account(mut)]`?;Оно явно разрешает программе изменять данные аккаунта. Без него любая попытка изменения вызовет ошибку. Это мера безопасности, чтобы случайно не изменить то, что не должно меняться.
Когда используется ограничение `#[account(init)]`?;Только тогда, когда мы создаем аккаунт "с нуля" в текущей инструкции. Для аккаунтов, которые уже существуют, `init` не нужен.
Зачем нужно ограничение `has_one = vault_x` в аккаунте `config`?;Это критически важная проверка безопасности. Она гарантирует, что `Pubkey`, переданный в аккаунте `vault_x`, в точности совпадает с тем `Pubkey`, который сохранен в поле `config.vault_x`. Это защищает от атаки, когда злоумышленник подсовывает "левое" хранилище, чтобы украсть средства.
Почему для минта LP-токенов мы использовали `CpiContext::new_with_signer`, а не `CpiContext::new`?;Потому что право на выпуск (mint authority) LP-токенов принадлежит не пользователю, а нашей программе через PDA (`config`). `new_with_signer` позволяет "подписать" CPI-вызов от имени PDA, используя `signer_seeds`.
Что такое `signer_seeds` и почему они так важны?;Это массив "семян" (байт), из которых был сгенерирован адрес PDA. Чтобы подписать транзакцию от имени PDA, мы должны предоставить в точности те же семена и `bump`. Это доказывает блокчейну, что именно наша программа имеет право управлять PDA.
Что делает оператор `?` в конце вызова функции в Rust?;Он автоматически обрабатывает тип `Result`. Если результат `Ok(value)`, он "распаковывает" `value`. Если результат `Err(error)`, он немедленно прекращает выполнение функции и возвращает эту ошибку.
Почему возникла ошибка `DeclaredProgramIdMismatch`?;Потому что ID программы, "зашитый" в Rust-коде (`declare_id!`), не совпадал с ID, который программа получила при развертывании через `anchor test`. Решение — удалить старый ключ (`target/deploy/программа-keypair.json`) и пересобрать проект (`anchor build`), чтобы ID синхронизировались.
Зачем мы добавляли зависимость `anchor-spl` в `Cargo.toml`?;Чтобы получить доступ к удобным функциям и структурам для работы с Токен-Программой Solana, таким как `TokenAccount`, `Mint`, `Transfer`, `MintTo` и функциям `token::transfer`, `token::mint_to`.
Почему `import assert from "assert"` в тесте не работал, а `import { assert } from "chai"` сработал?;Это связано с особенностями работы тестового фреймворка `ts-mocha` и тем, как он обрабатывает модули. `chai` — это стандартная и более надежная библиотека для проверок (`assertions`) в тестах Anchor, и ее импорт работает стабильнее.
Что делает команда `anchor build`?;Она компилирует Rust-код программы в BPF-байткод, который может исполняться в сети Solana, а также генерирует IDL (JSON-файл), который описывает интерфейс программы для взаимодействия с ней из TypeScript.
Зачем нужен `airdrop` в тестах?;Чтобы пополнить баланс кошелька, который используется для развертывания программы и оплаты комиссий за транзакции. Без SOL на балансе транзакции не могут быть выполнены.
В чем разница между `Signer<'info>` и `Account<'info, T>`?;`Signer` — это тип, который представляет собой аккаунт, подписавший транзакцию. Он доказывает, что владелец приватного ключа одобрил действие. `Account` представляет собой аккаунт, хранящий данные, которые Anchor автоматически десериализует в указанную структуру `T`.
